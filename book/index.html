<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction - modrpc</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">modrpc</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Modrpc is a RPC (remote procedure call) framework much like gRPC, Thrift, and Cap'n Proto. Users describe their application's interface in modrpc's interface definition language (IDL), and boilerplate code to implement the interface's participants is automatically generated in any of the languages that modrpc supports. Here's what a simple modrpc schema looks like:</p>
<pre><code>import std ".modrpc/std.modrpc"

interface Chat @(Client, Server) {
    objects {
        register: std.Request&lt;
            RegisterRequest,
            result&lt;void, RegisterError&gt;,
        &gt; @(Client, Server),

        send_message: std.Request&lt;
            SendMessageRequest,
            result&lt;void, SendMessageError&gt;,
        &gt; @(Client, Server),
    }

    state {
        users: [RegisteredUser],
    }
}

struct RegisteredUser {
    endpoint_addr: u64,
    alias: string,
}

struct RegisterRequest {
    alias: string,
}

enum RegisterError {
    UserAlreadyExists,
    Internal,
}

struct SendMessageRequest {
    content: string,
}

enum SendMessageError {
    Internal,
    InsufficientRizz,
}
</code></pre>
<p>Check out <a href="https://github.com/modrpc-org/chat-modrpc-example">chat-modrpc-example</a> to see a working example application.</p>
<p>Modrpc focuses on the following areas:</p>
<ul>
<li>modularity</li>
<li>portability</li>
<li>RPC over multicast</li>
<li>performance</li>
</ul>
<h2 id="portability"><a class="header" href="#portability">Portability</a></h2>
<p>This refers to making modrpc usable in as many situations as possible. There are a few design goals aimed at that (some are currently aspirational):</p>
<ul>
<li>Don't allocate after startup (important for embedded use-cases)</li>
<li>Be transport-agnostic - support communication over shared-memory, TCP, WebSockets, or even an embedded radio.</li>
<li>Try to be as lightweight as possible.</li>
</ul>
<h2 id="rpc-over-multicast"><a class="header" href="#rpc-over-multicast">RPC over multicast</a></h2>
<p>Here "multicast" means events for a modrpc interface being broadcasted to all interested peers. This allows you to, for example, have all clients see each others' requests and the server's responses to those requests. This is useful when developing collaborative apps and in many cases allows you to avoid building dedicated mechanisms to sync state among peers.</p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>Modrpc aims to be lightweight and easy to setup in simple single-threaded scenarios, but also aims to be easily scalable to support high-throughput, high concurrency scenarios (tens to hundreds of thousands of tasks interacting with the RPC system). The runtime is written in Rust and is <code>async</code> and thread-per-core. Some examples of performance-oriented design decisions:</p>
<ul>
<li>Avoid frequent heap allocations
<ul>
<li>A fixed-size, async buffer pool is used to allocate messages.</li>
<li>Messages can be serialized and deserialized without allocations.</li>
</ul>
</li>
<li>Batching
<ul>
<li>Threads grab buffers from the shared pool in batches to allocate messages on.</li>
<li>Multiple messages can be backed by a single buffer.</li>
<li>Written buffers are flushed for sending out on a transport in batches.</li>
<li>Inter-thread message queues automatically batch under high load.</li>
</ul>
</li>
<li>Thread-local waker registrations
<ul>
<li>Use non-<code>Sync</code> async datastructures where possible.</li>
<li>In some datastructures (for example <code>modrpc::HeapBufferPool</code>), when there are many tasks on multiple threads that need to be notified, only one task per thread will register itself in a thread-safe queue - others will wait in a thread-local queue.</li>
</ul>
</li>
<li>Scaling across cores / load balancing
<ul>
<li>Message handlers on multiple threads can subscribe to a load-balancing mpmc queue to receive work.</li>
<li>A message will be processed directly on the received thread if possible to circumvent the mpmc queue and some buffer reference counting.</li>
</ul>
</li>
</ul>
<p>Check out the <a href="https://github.com/modrpc-org/modrpc/blob/c8be8fde5eb34fcc23949bd2cc712e1939298b10/examples/local-benchmark/src/main.rs">local-benchmark</a> example application to get a sense for what configuring a multithreaded modrpc runtime with multiple transports looks like.</p>
<p>To get an idea of current performance, try out the <a href="https://github.com/modrpc-org/modrpc/tree/main/examples/p2p-benchmark">p2p-benchmark</a> example application - it has a single-threaded server being spammed with very cheap requests by a multi-threaded client. On my laptop the server is able to serve 3.8M+ requests/second.</p>
<h2 id="modularity"><a class="header" href="#modularity">Modularity</a></h2>
<p>Modrpc allows users to define interfaces that can be implemented once in Rust and imported and re-used as components of larger interfaces. In the earlier example, we encountered the <code>std.Request</code> interface from modrpc's standard library. As you might've guessed, this interface provides the request-response pattern that comes baked into traditional RPC frameworks.</p>
<p>The definition of <code>std.Request</code>:</p>
<pre><code>interface Request&lt;Req, Resp&gt; @(Client, Server) {
    events @(Client) -&gt; @(Client, Server) {
        private request: Request&lt;Req&gt;,
    }

    events @(Server) -&gt; @(Client) {
        private response: Response&lt;Resp&gt;,
    }

    impl @(Server) {
        handler: async Req -&gt; Resp,
    }

    methods @(Client) {
        call: async Req -&gt; Resp,
    }
}
</code></pre>
<p>All interfaces boil down to events that can be sent from some set of roles to some other set of roles. In the case of <code>std.Request</code>, only clients can send requests, and both clients and servers will receive them. This allows clients to observe requests made by other clients when doing RPC-over-multicast.</p>
<p>Common logic for a re-usable interface is hand-written once in Rust, and downstream interfaces and applications can invoke the logic via methods that the re-usable interface exposes. An example of this is the <code>call</code> method on <code>std.Request</code>.</p>
<p>If the re-usable interface requires application-specific logic, these are specified via <code>impl</code> blocks. In the case of <code>std.Request</code>, implementers of a request server must provide an async function that receives a request and produces a response.</p>
<p>Under the hood, the re-usable Rust implementation of the <code>Request</code> interface handles request payload encapsulation and response tracking / notification at the <a href="https://github.com/modrpc-org/modrpc/blob/c8be8fde5eb34fcc23949bd2cc712e1939298b10/std-modrpc/rust/src/role_impls/request_client.rs#L192-L248">client</a> and calling the user's supplied request handler at the <a href="https://github.com/modrpc-org/modrpc/blob/c8be8fde5eb34fcc23949bd2cc712e1939298b10/std-modrpc/rust/src/role_impls/request_server.rs#L91-L115">server</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->

                            <a rel="next prefetch" href="getting-started.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

                    <a rel="next prefetch" href="getting-started.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
