<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>modrpc</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">modrpc</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Modrpc is a RPC (remote procedure call) framework much like gRPC, Thrift, and Cap'n Proto. Users describe their application's interface in modrpc's interface definition language (IDL), and boilerplate code to implement the interface's participants is automatically generated in any of the languages that modrpc supports. Here's what a simple modrpc schema looks like:</p>
<pre><code>import std ".modrpc/std.modrpc"

interface Chat @(Client, Server) {
    objects {
        register: std.Request&lt;
            RegisterRequest,
            result&lt;void, RegisterError&gt;,
        &gt; @(Client, Server),

        send_message: std.Request&lt;
            SendMessageRequest,
            result&lt;void, SendMessageError&gt;,
        &gt; @(Client, Server),
    }

    state {
        users: [RegisteredUser],
    }
}

struct RegisteredUser {
    endpoint_addr: u64,
    alias: string,
}

struct RegisterRequest {
    alias: string,
}

enum RegisterError {
    UserAlreadyExists,
    Internal,
}

struct SendMessageRequest {
    content: string,
}

enum SendMessageError {
    Internal,
    InsufficientRizz,
}
</code></pre>
<p>Check out <a href="https://github.com/modrpc-org/chat-modrpc-example">chat-modrpc-example</a> to see a working example application.</p>
<p>Modrpc focuses on the following areas:</p>
<ul>
<li>modularity</li>
<li>portability</li>
<li>RPC over multicast</li>
<li>performance</li>
</ul>
<h2 id="portability"><a class="header" href="#portability">Portability</a></h2>
<p>This refers to making modrpc usable in as many situations as possible. There are a few design goals aimed at that (some are currently aspirational):</p>
<ul>
<li>Don't allocate after startup (important for embedded use-cases)</li>
<li>Be transport-agnostic - support communication over shared-memory, TCP, WebSockets, or even an embedded radio.</li>
<li>Try to be as lightweight as possible.</li>
</ul>
<h2 id="rpc-over-multicast"><a class="header" href="#rpc-over-multicast">RPC over multicast</a></h2>
<p>Here "multicast" means events for a modrpc interface being broadcasted to all interested peers. This allows you to, for example, have all clients see each others' requests and the server's responses to those requests. This is useful when developing collaborative apps and in many cases allows you to avoid building dedicated mechanisms to sync state among peers.</p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>Modrpc aims to be lightweight and easy to setup in simple single-threaded scenarios, but also aims to be easily scalable to support high-throughput, high concurrency scenarios (tens to hundreds of thousands of tasks interacting with the RPC system). The runtime is written in Rust and is <code>async</code> and thread-per-core. Some examples of performance-oriented design decisions:</p>
<ul>
<li>Avoid frequent heap allocations
<ul>
<li>A fixed-size, async buffer pool is used to allocate messages.</li>
<li>Messages can be serialized and deserialized without allocations.</li>
</ul>
</li>
<li>Batching
<ul>
<li>Threads grab buffers from the shared pool in batches to allocate messages on.</li>
<li>Multiple messages can be backed by a single buffer.</li>
<li>Written buffers are flushed for sending out on a transport in batches.</li>
<li>Inter-thread message queues automatically batch under high load.</li>
</ul>
</li>
<li>Thread-local waker registrations
<ul>
<li>Use non-<code>Sync</code> async datastructures where possible.</li>
<li>In some datastructures (for example <code>modrpc::HeapBufferPool</code>), when there are many tasks on multiple threads that need to be notified, only one task per thread will register itself in a thread-safe queue - others will wait in a thread-local queue.</li>
</ul>
</li>
<li>Scaling across cores / load balancing
<ul>
<li>Message handlers on multiple threads can subscribe to a load-balancing mpmc queue to receive work.</li>
<li>A message will be processed directly on the received thread if possible to circumvent the mpmc queue and some buffer reference counting.</li>
</ul>
</li>
</ul>
<p>Check out the <a href="https://github.com/modrpc-org/modrpc/blob/c8be8fde5eb34fcc23949bd2cc712e1939298b10/examples/local-benchmark/src/main.rs">local-benchmark</a> example application to get a sense for what configuring a multithreaded modrpc runtime with multiple transports looks like.</p>
<p>To get an idea of current performance, try out the <a href="https://github.com/modrpc-org/modrpc/tree/main/examples/p2p-benchmark">p2p-benchmark</a> example application - it has a single-threaded server being spammed with very cheap requests by a multi-threaded client. On my laptop the server is able to serve 3.8M+ requests/second.</p>
<h2 id="modularity"><a class="header" href="#modularity">Modularity</a></h2>
<p>Modrpc allows users to define interfaces that can be implemented once in Rust and imported and re-used as components of larger interfaces. In the earlier example, we encountered the <code>std.Request</code> interface from modrpc's standard library. As you might've guessed, this interface provides the request-response pattern that comes baked into traditional RPC frameworks.</p>
<p>The definition of <code>std.Request</code>:</p>
<pre><code>interface Request&lt;Req, Resp&gt; @(Client, Server) {
    events @(Client) -&gt; @(Client, Server) {
        private request: Request&lt;Req&gt;,
    }

    events @(Server) -&gt; @(Client) {
        private response: Response&lt;Resp&gt;,
    }

    impl @(Server) {
        handler: async Req -&gt; Resp,
    }

    methods @(Client) {
        call: async Req -&gt; Resp,
    }
}
</code></pre>
<p>All interfaces boil down to events that can be sent from some set of roles to some other set of roles. In the case of <code>std.Request</code>, only clients can send requests, and both clients and servers will receive them. This allows clients to observe requests made by other clients when doing RPC-over-multicast.</p>
<p>Common logic for a re-usable interface is hand-written once in Rust, and downstream interfaces and applications can invoke the logic via methods that the re-usable interface exposes. An example of this is the <code>call</code> method on <code>std.Request</code>.</p>
<p>If the re-usable interface requires application-specific logic, these are specified via <code>impl</code> blocks. In the case of <code>std.Request</code>, implementers of a request server must provide an async function that receives a request and produces a response.</p>
<p>Under the hood, the re-usable Rust implementation of the <code>Request</code> interface handles request payload encapsulation and response tracking / notification at the <a href="https://github.com/modrpc-org/modrpc/blob/c8be8fde5eb34fcc23949bd2cc712e1939298b10/std-modrpc/rust/src/role_impls/request_client.rs#L192-L248">client</a> and calling the user's supplied request handler at the <a href="https://github.com/modrpc-org/modrpc/blob/c8be8fde5eb34fcc23949bd2cc712e1939298b10/std-modrpc/rust/src/role_impls/request_server.rs#L91-L115">server</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This guide will walk you through starting your first modrpc project. It assumes you have already installed Rust - see <a href="https://rustup.rs">rustup.rs</a>.</p>
<h3 id="1-install-the-modrpc-tooling"><a class="header" href="#1-install-the-modrpc-tooling">1. Install the modrpc tooling</a></h3>
<pre><code>cargo install modrpcc
</code></pre>
<h3 id="2-create-the-structure-of-your-modrpc-project"><a class="header" href="#2-create-the-structure-of-your-modrpc-project">2. Create the structure of your modrpc project</a></h3>
<pre><code>mkdir my-modrpc-app
cd my-modrpc-app

cargo new --bin --name my-server server
cargo new --bin --name my-client client
</code></pre>
<h3 id="3-download-the-modrpc-standard-library"><a class="header" href="#3-download-the-modrpc-standard-library">3. Download the modrpc standard library</a></h3>
<p>Currently the modrpc standard library is unversioned. Download the latest proof-of-concept schema straight from the GitHub repo - it will be kept in-sync with the latest <code>std-modrpc</code> on crates.io.</p>
<pre><code>mkdir .modrpc
curl https://raw.githubusercontent.com/modrpc-org/modrpc/refs/heads/main/proto/std.modrpc -o .modrpc/std.modrpc
</code></pre>
<h3 id="4-define-your-first-interface"><a class="header" href="#4-define-your-first-interface">4. Define your first interface</a></h3>
<p>Populate <code>my-app.modrpc</code>:</p>
<pre><code>import std ".modrpc/std.modrpc"

interface MyApp @(Client, Server) {
    objects {
        compute_fizzbuzz: std.Request&lt;
            ComputeFizzbuzzRequest,
            result&lt;ComputeFizzbuzzSuccess, ComputeFizzbuzzError&gt;,
        &gt; @(Client, Server),
    }
}

struct ComputeFizzbuzzRequest {
    i: u64,
}

struct ComputeFizzbuzzSuccess {
    message: string,
}

enum ComputeFizzbuzzError {
    InvalidRequest,
}
</code></pre>
<h3 id="5-generate-the-modrpc-glue-library-for-your-interface"><a class="header" href="#5-generate-the-modrpc-glue-library-for-your-interface">5. Generate the modrpc glue library for your interface</a></h3>
<p>This will generate a Rust crate at <code>my-app-modrpc/rust</code>:</p>
<pre><code>modrpcc --language rust --output-dir . --name my-app my-app.modrpc
</code></pre>
<h3 id="6-implement-your-server"><a class="header" href="#6-implement-your-server">6. Implement your server</a></h3>
<p>Move to the server's directory:</p>
<pre><code>cd server
</code></pre>
<p>Populate <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = "my-server"
version = "0.1.0"
edition = "2024"

[dependencies]
modrpc = { version = "0.0", features = ["tcp-transport"] }
modrpc-executor = { version = "0.0", features = ["tokio"] }
my-app-modrpc = { path = "../my-app-modrpc/rust" }
std-modrpc = "0.0"
tokio = "1"
</code></pre>
<p>Populate <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use modrpc_executor::ModrpcExecutor;

fn main() {
    let mut ex = modrpc_executor::TokioExecutor::new();
    let _guard = ex.tokio_runtime().enter();

    let buffer_pool = modrpc::HeapBufferPool::new(256, 4, 4);
    let rt = modrpc::RuntimeBuilder::new_with_local(ex.spawner());
    let (rt, _rt_shutdown) = rt.start::&lt;modrpc_executor::TokioExecutor&gt;();

    ex.run_until(async move {
        let tcp_server = modrpc::TcpServer::new();
        let listener = tokio::net::TcpListener::bind("0.0.0.0:9090").await
            .expect("tcp listener");

        loop {
            println!("Waiting for client...");
            let (stream, client_addr) = match listener.accept().await {
                Ok(s) =&gt; s,
                Err(e) =&gt; {
                    println!("Failed to accept client: {}", e);
                    continue;
                }
            };
            stream.set_nodelay(true).unwrap();

            let _ = tcp_server.accept_local::&lt;my_app_modrpc::MyAppServerRole&gt;(
                &amp;rt,
                buffer_pool.clone(),
                stream,
                start_my_app_server,
                my_app_modrpc::MyAppServerConfig { },
                my_app_modrpc::MyAppInitState { },
            )
            .await
            .unwrap();

            println!("Accepted client {}", client_addr);
        }
    });
}

fn start_my_app_server(
    cx: modrpc::RoleWorkerContext&lt;my_app_modrpc::MyAppServerRole&gt;,
) {
    cx.stubs.compute_fizzbuzz.build(cx.setup, async move |_source, request| {
        use my_app_modrpc::{ComputeFizzbuzzError, ComputeFizzbuzzSuccess};

        let Ok(i) = request.i() else {
            return Err(ComputeFizzbuzzError::InvalidRequest);
        };

        println!("Received request: {i}");

        let response = if i % 3 == 0 &amp;&amp; i % 5 == 0 {
            ComputeFizzbuzzSuccess { message: "FizzBuzz".to_string() }
        } else if i % 3 == 0 {
            ComputeFizzbuzzSuccess { message: "Fizz".to_string() }
        } else if i % 5 == 0 {
            ComputeFizzbuzzSuccess { message: "Buzz".to_string() }
        } else {
            ComputeFizzbuzzSuccess { message: format!("{i}") }
        };

        println!("  response: {response:?}");

        Ok(response)
    });
}</code></pre></pre>
<p>Build and run the server:</p>
<pre><code>cargo run --release
</code></pre>
<h3 id="7-implement-your-client"><a class="header" href="#7-implement-your-client">7. Implement your client</a></h3>
<p>In another terminal session, move to the client's directory:</p>
<pre><code>cd /path/to/my-modrpc-app/client
</code></pre>
<p>Populate <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = "my-client"
version = "0.1.0"
edition = "2024"

[dependencies]
modrpc = { version = "0.0", features = ["tcp-transport"] }
modrpc-executor = { version = "0.0", features = ["tokio"] }
my-app-modrpc = { path = "../my-app-modrpc/rust" }
std-modrpc = "0.0"
tokio = "1"
</code></pre>
<p>Populate <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use modrpc_executor::ModrpcExecutor;

fn main() {
    let mut ex = modrpc_executor::TokioExecutor::new();
    let _guard = ex.tokio_runtime().enter();

    let buffer_pool = modrpc::HeapBufferPool::new(256, 4, 4);
    let rt = modrpc::RuntimeBuilder::new_with_local(ex.spawner());
    let (rt, _rt_shutdown) = rt.start::&lt;modrpc_executor::TokioExecutor&gt;();

    ex.run_until(async move {
        let stream = tokio::net::TcpStream::connect("127.0.0.1:9090").await
            .expect("tcp stream connect");
        stream.set_nodelay(true).unwrap();

        println!("Connected to server");

        let connection =
            modrpc::tcp_connect::&lt;my_app_modrpc::MyAppClientRole&gt;(
                &amp;rt,
                buffer_pool,
                modrpc::WorkerId::local(),
                my_app_modrpc::MyAppClientConfig { },
                stream,
            )
            .await
            .unwrap();
        let my_app_client = connection.role_handle;

        for i in 1..=15 {
            let response = my_app_client.compute_fizzbuzz.call(
                my_app_modrpc::ComputeFizzbuzzRequest { i }
            )
            .await
            .expect("fizzbuzz failed");

            println!("{}", response.message);
        }
    });
}</code></pre></pre>
<p>Build and run the client:</p>
<pre><code>cargo run --release
</code></pre>
<p>The end!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="motivating-example---task-manager"><a class="header" href="#motivating-example---task-manager">Motivating example - task manager</a></h1>
<p>Imagine you have an app (or several) that manages many different kinds of long-running tasks. And you're a stickler for avoiding unnecessary communications, so you want the client to keep track of all pending tasks and only receive status updates, never poll. So you write a re-usable <code>TaskManager</code> interface to encapsulate the common logic of spawning, tracking, and optionally canceling tasks.</p>
<pre><code>interface TaskManager&lt;SpawnPayload, State, Error&gt; @(Client, Server) {
    objects {
        spawn: std.Request&lt;
            SpawnRequest&lt;SpawnPayload&gt;,
            result&lt;void, SpawnError&lt;Error&gt;&gt;,
        &gt; @(Client, Server),

        cancel: std.Request&lt;
            TaskId,
            result&lt;void, CancelError&gt;,
        &gt; @(Client, Server),

        // server -&gt; client ordered streams (per-task) of status updates
        task_status_update: std.MultiStream&lt;TaskStatus&lt;State&gt;&gt; @(Client, Server),
    }

    impl @(Server) {
        new_task: NewTask&lt;SpawnPayload&gt; -&gt; void,
    }

    methods @(Server) {
        post_status: PostTaskStatus&lt;State&gt; -&gt; void,
    }

    methods @(Client) {
        spawn: async SpawnPayload -&gt; result&lt;SpawnSuccess, SpawnError&lt;Error&gt;&gt;,
        cancel: async TaskId -&gt; result&lt;void, CancelError&gt;,
    }

    state {
        pending_tasks: [TaskId],
    }
}

struct TaskId { id: u64 }

struct SpawnSuccess {
    task_id: TaskId,
    status_stream: std.MultiStreamId,
}

// ... some definitions omitted
</code></pre>
<p>One of your apps is a worker for a pipeline that downloads and transcodes cat videos:</p>
<pre><code>interface CatVideoTranscoder @(Client, Server) {
    objects {
        cat_video_downloads: TaskManager&lt;CatUrl, CatState, CatDownloadSpawnError&gt; @(Client, Server),

        h264_to_h265_transcoding: TaskManager&lt;CatVideoId, VideoTranscodingState, VideoTranscodingSpawnError&gt; @(Client, Server),
    }
}

// ... some definitions omitted
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
